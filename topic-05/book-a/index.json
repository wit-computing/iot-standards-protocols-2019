


  {
  
  
    "properties" : {},
  
  "type" : "lab",
  "title" : "Messaging Lab",
  "img" : "img/main.png",
  "videoid" : "none",
  "objectives" : "<p>Use HTTP and MQTT to connect a device</p>",
  "folder" : "book-a",
  "link" : "index.html",
  "los": [
   ]
,
  "chapters" : [
  
    {
    "title": "# MQTT Publish and Subscribe",
    "shortTitle": "Messaging Lab",
    "contentMd" : "# MQTT Publish and Subscribe\r\n\r\nUse HTTP and MQTT to connect a device\r\n\r\n## Introduction\r\nYou will use the  Raspberry Pi as our sensor device to publish temperature, pressure and humidity data. It will send a current value of every sensor to a MQTT broker. There are many public MQTT brokers (you can set up your own). In this lab you can choose one of the following public brokers.\r\n\r\n+ mqtt://iot.eclipse.org:1883\r\n+ mqtt://broker.hivemq.com:1883\r\n+ mqtt://test.mosquitto.org:1883\r\n\r\nIt is up to you which one you choose for the lab - perhaps try a few of them! \r\nAs they are public brokers there is no guarantee of service (personally I found broker.hivemq.com slow). If you wish to have some reassurance of performance and authentication, there are several services available that offer a free tier such as [cloudmqtt](https://www.cloudmqtt.com).\r\n\r\n![MQTT Publish-Subscribe](./img/main.png)\r\n\r\n\r\n## Equipment, Software\r\n\r\n+ Raspberry Pi 3 B\r\n+ SenseHAT\r\n+ Cloud MQTT Broker\r\n+ TinyDB and/or MLab MongoDB\r\n\r\n"
    },
  
    {
    "title": "##Set up",
    "shortTitle": "01",
    "contentMd" : "##Set up\r\n\r\n### Update the RPi\r\nRun the following to make sure your RPi libraries are up to date:\r\n\r\n```bash\r\nsudo apt-get update\r\n```\r\n\r\n### Eclipse Paho\r\nYou will use the [Eclipse Paho Python client library](https://pypi.org/project/paho-mqtt/) to create a publish and subscribe program as shown in the above diagram. Run the following command in the RPi To install the relevant libraries on the RPi:\r\n\r\n```bash\r\nsudo apt-get install mosquitto\r\n```\r\n```bash\r\nsudo pip install paho-mqtt\r\n```\r\n\r\n### SenseHat \r\nYou will need to install the relevant SenseHAT Python libraries. Run the following command in the RPi To install the relevant libraries on the RPi:\r\n\r\n```bash\r\nsudo apt-get install sense-hat\r\n```\r\n\r\n\r\n##Publish Temperature\r\n\r\n+ On the Raspberry Pi, create a directory called ``mqtt`` in your home directory and ``cd`` into it:\r\n\r\n~~~bash\r\nmkdir ~/mqtt\r\ncd mqtt\r\n~~~\r\n\r\n+ Create a new script called ``client_pub.py`` and enter the following code:\r\n\r\n~~~python\r\nimport paho.mqtt.client as mqtt\r\nimport urlparse\r\nimport sys\r\nimport time\r\nimport json\r\nfrom sense_hat import SenseHat\r\n\r\nsense = SenseHat()\r\nsense.clear()\r\n# Define event callbacks\r\ndef on_connect(client, userdata, flags, rc):\r\n    print(\"Connection Result: \" + str(rc))\r\n\r\ndef on_publish(client, obj, mid):\r\n    print(\"Message ID: \" + str(mid))\r\n\r\nmqttc = mqtt.Client()\r\n\r\n# Assign event callbacks\r\nmqttc.on_connect = on_connect\r\nmqttc.on_publish = on_publish\r\n\r\n# parse mqtt url for connection details\r\nurl_str = sys.argv[1]\r\nprint(url_str)\r\nurl = urlparse.urlparse(url_str)\r\nbase_topic = url.path[1:]\r\n\r\n# Connect\r\nif (url.username):\r\n    mqttc.username_pw_set(url.username, url.password)\r\nmqttc.connect(url.hostname, url.port)\r\nmqttc.loop_start()\r\n\r\n# Publish a message to temp every 15 seconds\r\nwhile True:\r\n    temp=round(sense.get_temperature(),2)\r\n    temp_json=json.dumps({\"temperature\":temp, \"timestamp\":time.time()})\r\n    mqttc.publish(base_topic+\"/temperature\", temp_json)\r\n    time.sleep(15)\r\n~~~\r\n\r\n+ Examine the above code. The program expects a MQTT URL as the first command line argument. The connection details for MQTT broker as then parsed from the URL. \r\n+ You will publish the temperature reading to the following URL: ``mqtt://iot.eclipse.org:1883/YOUR_ID/home`` where you replace ``YOUR_ID`` in the URL with a memorable id of your choice (For example, I use my Github username, ``fxwalsh``, so my URL is : ``mqtt://iot.eclipse.org:1883/fxwalsh/home``).\r\n+ The program publishes the temperature and a timestamp from the device in question, which in this case is the time in seconds since the 1/1/1970 as a floating point number(the Linux epoch).\r\n+ Run the program, ``python client_pub.py mqtt://iot.eclipse.org:1883/YOUR_ID/home`` and you should see an output to the console similar to the following:\r\n\r\n~~~bash\r\nmqtt://iot.eclipse.org:1883/fxwalsh/home\r\nMessage ID: 1\r\nConnection Result: 0\r\nMessage ID: 2\r\nMessage ID: 3\r\nMessage ID: 4\r\n~~~\r\n\r\nThe ``Message ID: ...`` indicates on_publish callback and is called every time a value is publuished to the broker.  ``Connection Result: 0`` is output from the on_connect callback and ``0`` is success but any other number indicates a refused connection. For a more detailed explaination see: [Paho Callbacks](https://pypi.org/project/paho-mqtt/#callbacks).\r\n\r\nYour RPi is now hopefully publishing temperature messages to the cloud MQTT broker. Any device can now subscribe and use this data.  \r\n**NOTE: Leave this program running for the next section**\r\n\r\n### Subscribe\r\n\r\nIdeally you can create the following program on another computer/device that can run Python but, if you only have the RPi, or just for convenience, it's OK to run the following subscribe program on the RPi also(just pretend it's on another device somewhere else in the world!).\r\n\r\n+ If you are using another device/laptop to subscribe, create a new directory called ``mqtt``. \r\n+ in the ``mqtt`` directory, create a new Python program file called ``client_sub.py`` with the following content:\r\n\r\n~~~python\r\nimport paho.mqtt.client as mqtt\r\nimport urlparse\r\nimport sys\r\n\r\n# Define event callbacks\r\ndef on_connect(client, userdata, flags, rc):\r\n    print(\"Connection Result: \" + str(rc))\r\n\r\ndef on_message(client, obj, msg):\r\n    print(\"Topic:\"+msg.topic + \",Payload:\" + str(msg.payload))\r\n\r\ndef on_subscribe(client, obj, mid, granted_qos):\r\n    print(\"Subscribed,  QOS granted: \"+ str(granted_qos))\r\n\r\nmqttc = mqtt.Client()\r\n\r\n# Assign event callbacks\r\nmqttc.on_message = on_message\r\nmqttc.on_connect = on_connect\r\nmqttc.on_subscribe = on_subscribe\r\n\r\n# parse mqtt url for connection details\r\nurl_str = sys.argv[1]\r\nurl = urlparse.urlparse(url_str)\r\nbase_topic = url.path[1:]\r\n\r\n# Connect\r\nif (url.username):\r\n    mqttc.username_pw_set(url.username, url.password)\r\nmqttc.connect(url.hostname, url.port)\r\n\r\n# Start subscribe, with QoS level 0\r\nmqttc.subscribe(base_topic+\"/#\", 0)\r\nmqttc.loop_forever()\r\n\r\n# Continue the network loop, exit when an error occurs\r\nrc = 0\r\nwhile rc == 0:\r\n    rc = mqttc.loop()\r\nprint(\"rc: \" + str(rc))\r\n~~~\r\n\r\n+ Now run it as before, **using the same URL used in for the publishing program** as a command line argument. You should see data output to the console similar to the following:\r\n\r\n~~~bash\r\nConnection Result: 0\r\nSubscribed,  QOS granted: (0,)\r\nTopic:fxwalsh/home/temperature,Payload:{\"timestamp\": 1541453620.862879, \"temperature\": 34.48}\r\nTopic:fxwalsh/home/temperature,Payload:{\"timestamp\": 1541453680.936523, \"temperature\": 34.41}\r\n~~~\r\n\r\nYou now have a working MQTT publisher/subscriber!\r\n\r\n## Multiple Topics\r\n\r\nThe SenseHAT on the RPi has a few other environment sensors, for example pressure and humidity. If you presume to operate the RPi as a weather station, you need to publish this data also and create a suiable channel structure for MQTT.\r\n+ On the RPi, stop ``client_pub.py`` by entering ``ctrl + c`` in the terminal window.\r\n+ On the RPi, create a new script in ``~/mqtt`` called  ``client_pub_mult.py`` with the following content:\r\n\r\n~~~python\r\nimport paho.mqtt.client as mqtt\r\nimport paho.mqtt.publish as publish\r\nimport urlparse\r\nimport sys\r\nimport time\r\nimport json\r\n\r\nfrom sense_hat import SenseHat\r\n\r\nsense = SenseHat()\r\nsense.clear()\r\n\r\n# parse mqtt url for connection details\r\nurl_str = sys.argv[1]\r\nprint(url_str)\r\nurl = urlparse.urlparse(url_str)\r\nbase_topic = url.path[1:]\r\nauth=None\r\n# Connect\r\nif (url.username):\r\n    auth = {'username':url.username, 'password':url.password}\r\n\r\n\r\n\r\n# Publish a message\r\nwhile True:\r\n    temp=round(sense.get_temperature(),2)\r\n    humidity=sense.get_humidity()\r\n\r\n    #Create JSON strings\r\n    temp_sensor=json.dumps({\"temperature\":temp, \"timestamp\":time.time()}) \r\n    humidity_sensor=json.dumps({\"humidity\":humidity, , \"timestamp\":time.time()}) \r\n\r\n    #Create array of MQTT messages\r\n    temp_msg={'topic': base_topic +\"/temperature\", 'payload':temp_sensor}\r\n    hum_msg={'topic':base_topic +\"/humidity\", 'payload':humidity_sensor}\r\n    msgs=[temp_msg,hum_msg]\r\n\r\n    #Publish array of messages\r\n    publish.multiple(msgs, hostname=url.hostname, port=url.port, auth=auth)\r\n    print(\"published\")\r\n    time.sleep(15)\r\n~~~\r\n\r\nThis time the program uses the publish.mutliple() function to send a list topics and payloads. \r\n\r\n+ The script is missing the pressure value. Inspect the script and update it to publish the pressure sensor reading to ``/pressure``.(hint: use ``sensor.get_pressure()`` to get the pressure value). All going well, you should observe output from the program similar to the following:\r\n\r\n~~~bash\r\nTopic:fxwalsh/home/temp,Payload:{'temperature': 34.7}\r\nTopic:fxwalsh/home/humidity,Payload:{'humidity': 48.56332015991211}\r\nTopic:fxwalsh/home/pressure,Payload:{'pressure': 1022.30786133}\r\nTopic:fxwalsh/home/temp,Payload:{'temperature': 34.74}\r\nTopic:fxwalsh/home/humidity,Payload:{'humidity': 48.578670501708984}\r\nTopic:fxwalsh/home/pressure,Payload:{'pressure': 1022.31079102}\r\n~~~\r\n\r\n### Payload size best practice\r\n\r\nHow many bytes are you using for the payload in each message at the moment? Payloads should be kept small as possible if only to be fair to others that use the Internet!\r\nIn your report, suggest ways to reduce the size of the payload, for example:\r\n\r\n~~~json\r\n{\"Temperature\": 20.635 }\r\n24 bytes \r\n\r\n{“t”:20.63}\r\n11 bytes\r\n~~~\r\n\r\n+ How small could you make the temperature message?(hint: MQTT does not mandate the use of JSON and do you really need the \"t\")\r\n\r\n+ At the moment you are publishing to 3 topics. In your report suggest a justification, if any, to do this. Furthermore, demonstrate with code, how you could combine temperature, pressure and humidity in one JSON message."
    },
  
    {
    "title": "# Data Persistence & Web APIs",
    "shortTitle": "02",
    "contentMd" : "# Data Persistence & Web APIs\r\n\r\nYou are producing data, but it's not persisted as of yet. You may need to access historical data at a later data for various reasons such as analytics, functional or regulatory reasons.\r\nSome online MQTT brokers offer a window of historical data but will probably lack the ability to extensively query the data.\r\nIn this section you will now build a simple data acquisition device to persist your data both locally and remotely and use Web APIs to access that data.\r\nMQTT is now \"moving\" the data from a temperature sensor to a message broker. We can now write a data auisition program to move that data into a DB. \r\n\r\n### A DB on the RPi\r\n\r\nLets assume that your RPi will also function as your DB host. For this you can use a JSON-based database called **TinyDB**. You will do this on the RPi for now but in a real world scenario the DB would probably exiest be on another server or cloud based service.\r\n\r\n\r\n+ Install TinyDB on the RPi\r\n\r\n~~~bash\r\npip install TinyDB\r\n~~~\r\n\r\nWe'll create a separate MQTT subscription to persist our data and populate the database\r\n\r\n+ Make a copy of ``client_sub.py`` called ``persist_sub.py`` and open it in an editor.\r\n+ Change the code in ``persist_sub_py`` as follows:\r\n + add the import statement to include TinyDB, Query and json.\r\n ~~~python\r\n import json\r\n from tinydb import TinyDB, Query\r\n db = TinyDB('db.json')\r\n ~~~\r\n + Find and change the subscription statement to just subscribe to temperature:\r\n\r\n ~~~python\r\n ...\r\n # Start subscribe, with QoS level 0\r\n mqttc.subscribe(base_topic+\"/temperature\", 0)\r\n ...\r\n ~~~\r\n\r\n + Replace the contents of the ``on_message`` callback function with the following to insert the JSON into the DB:\r\n \r\n ~~~python\r\n    print(\"Insering into DB: \"+msg.payload)\r\n    msg_json=json.loads(msg.payload)\r\n    db.insert(msg_json)\r\n ~~~\r\n  \r\n+ Now run ``persist_sub.py``. Any temperature data published will now be persisted to the DB.\r\n\r\n+ If it's not still running, run ``client_pub.py'' program on the RPi again and leave it generate some temperature messages. \r\n\r\n\r\n+ Open ``db.json`` in a text editor. You should see messages beginning to be the persisted in the file similar to the following:\r\n\r\n~~~json\r\n{\"_default\": {\"1\": {\"timestamp\": 1541234209.524762, \"temperature\": \"18.77\"}, \"2\": {\"timestamp\": 1541234224.785746, \"temperature\": \"18.77\"},\r\n~~~\r\n\r\n### Simple Analytics\r\n\r\nLets say you want to analyse the data to find the following:\r\n\r\n+ Maximum temp recorded\r\n+ Minimum temp recorded\r\n+ Average temp recorded\r\n\r\nYou can do this both programatically and using the Python console as follows\r\n\r\n+ In the same directory as the ``db.json`` file,  start the Python console by typing ``python`` in a terminal window.\r\n\r\n+ Type the following commands\r\n\r\n\r\n~~~python\r\n>>> from tinydb import TinyDB, Query\r\n>>> db = TinyDB('db.json')\r\n~~~\r\n\r\n+ List all items in the db:\r\n~~~python\r\n>>> for item in db:\r\n...     print(item)\r\n... (HIT RETURN ON THIS LINE!)\r\n{u'timestamp': 1541453440.878712, u'temperature': 34.67}\r\n{u'timestamp': 1541453455.783444, u'temperature': 34.5}\r\n{u'timestamp': 1541453470.80211, u'temperature': 34.54}\r\n{u'timestamp': 1541453485.814092, u'temperature': 34.63}\r\n{u'timestamp': 1541453500.839073, u'temperature': 34.61}\r\n{u'timestamp': 1541453515.855052, u'temperature': 34.76}\r\n{u'timestamp': 1541453530.868686, u'temperature': 34.74}\r\n{u'timestamp': 1541453545.887301, u'temperature': 34.5}\r\n~~~\r\n\r\n+ Find all occurrences of  temperature less than 34.5:\r\n\r\n~~~python\r\n>>> Temp = Query()\r\n>>> db.search(Temp.temperature < 34.5)\r\n[{u'temperature': 33.93}, {u'temperature': 33.84}, {u'temperature': 33.84}, {u'temperature': 33.84}, {u'temperature': 33.97}, {u'temperature': 33.86}, {u'temperature': 33.7}, {u'temperature': 34.06}, {u'temperat.....\r\n>>> \r\n~~~\r\n\r\n+ Using the above examples, run the following python script to extract max,min and average temp.\r\n\r\n~~~python\r\nfrom tinydb import TinyDB, Query\r\ndb = TinyDB('db.json')\r\n\r\n## get a list of temps from the DB\r\ntemps = [float(item['temperature']) for item in db]\r\nprint(min(temps))\r\nprint(max(temps))\r\nprint(sum(temps)/len(temps))\r\n~~~\r\n\r\n### Web API\r\n\r\nLets assume you wish to make the temperature data available via a web API. This might be useful for weather station dashboard or other applications, both current and in the future, that need access to the data.\r\n\r\n+ Install Flask\r\n\r\n~~~bash\r\npip install flask\r\n~~~\r\n\r\n+ To allow cross origin requests (CORS). We will also use the ``flask-cors`` library. Although not used in this lab, it would be useful if you use this API in another web application/web site.\r\n\r\n```bash\r\npip install -U flask-cors\r\n```\r\n\r\nFlask is a web framework written in Python that allow you, among other things, to implement web APIs.\r\n\r\n\r\n+ Create a Python module called ``temp_db_data.py`` that exposes the functions that do simple analysis on the data:\r\n\r\n~~~python\r\nfrom tinydb import TinyDB, Query\r\nimport time,datetime\r\ndb = TinyDB('db.json')\r\n\r\ntemps = [float(item['temperature']) for item in db]\r\n\r\ndef min_temp():\r\n    return min(temps)\r\n\r\ndef max_temp():\r\n    return max(temps)\r\n\r\ndef mean_temp():\r\n    return sum(temps)/len(temps)\r\n\r\ndef temp_items(start,end):\r\n    temps = Query()\r\n    return db.search((temps.timestamp >= start) & (temps.timestamp <= end))\r\n~~~\r\n\r\nYou will create an API according to the following design:\r\n\r\n![Sense Web API](./img/api.png)\r\n\r\n+ Write a python program called ``sense_api.py`` that exposes the above module functions as a web API :\r\n\r\n~~~python\r\nfrom flask import Flask, request\r\nfrom flask_cors import CORS\r\nimport temp_db_data\r\nfrom sense_hat import SenseHat\r\n\r\nsense = SenseHat()\r\n\r\n#clear sensehat and intialise light_state\r\nsense.clear()\r\n\r\n\r\napp = Flask(__name__)\r\nCORS(app)\r\n\r\n@app.route('/sensehat/temp',methods=['GET'])\r\ndef current_temp():\r\n    temp=round(sense.get_temperature(),2)\r\n    return str(temp)\r\n\r\n@app.route('/sensehat/temp/<metric>',methods=['GET'])\r\ndef temp_metric(metric):\r\n    if (metric== \"mean\"): \r\n        return str(temp_db_data.mean_temp())\r\n    if (metric== \"max\"):\r\n        return str(temp_db_data.max_temp())\r\n    if (metric== \"min\"): \r\n        return str(temp_db_data.min_temp())\r\n    return \"Metric not found\"\r\n\r\n@app.route('/sensehat/light',methods=['POST'])\r\ndef light_post():\r\n    state=request.args.get('state')\r\n    print (state)\r\n    if (state==\"on\"):\r\n        sense.clear(255,255,255)\r\n        return '{\"state\":\"on\"}'\r\n    else: \r\n        sense.clear(0,0,0)\r\n        return '{\"state\":\"off\"}'\r\n\r\n@app.route('/sensehat/light',methods=['GET'])\r\ndef light_get():\r\n    #check top left pixel value(==0 - off, >0 - on) \r\n    print(sense.get_pixel(0, 0)) \r\n    if sense.get_pixel(0, 0)[0] == 0:\r\n    \treturn '{\"state\":\"off\"}'\r\n    else:\r\n\t    return '{\"state\":\"on\"}'\r\n\r\nif __name__ == \"__main__\":\r\n    app.run(host='0.0.0.0', port=5000, debug=True)\r\n~~~\r\n\r\nFinally, configure Flask to use your service and run it by entering the following commands at the command line(**Note: this is for  Unix/RPi):\r\n\r\n~~~bash\r\nFLASK_APP=hello.py\r\npython temp_api.py\r\n~~~\r\n\r\nThis will start the HTTP server on port 5000. \r\nYou should now be able to access the API using HTTP.\r\n\r\n### Curl it\r\n\r\nYou can use [Curl](https://curl.haxx.se/) to check if the API is responding. \r\n\r\n+ Find the IP address of the RPi using the ``ifconfig`` command\r\n+ Run ``Curl GET`` to request the URL resource you want...\r\n\r\n```bash\r\ncurl http://YOUR_PI_IP:5000/sensehat/temp\r\n```\r\n\r\n+ Enter the above URL into the address field of a browser and you should see something similar to the following:\r\n\r\n![Browser HTTP Request](./img/browser.png)\r\n\r\n+ Get the mean temperature as follows:\r\n\r\n```bash\r\ncurl http://YOUR_PI_IP:5000/sensehat/temp/mean\r\n```\r\n+Now try getting minimum and maximum recorded temperature by requesting ``sensehat/temp/min`` and ``sensehat/temp/max``\r\n\r\n+ Turn on the LED array (light) using a  ``HTTP POST`` request to ``/sensehat/light`` with the query string ``state=on`` as follows:\r\n\r\n```bash\r\ncurl -X POST http://YOUR_PI_IP:5000/sensehat/light?state=on\r\n```\r\n\r\n+ Turn it off using a query string ``state=off``\r\n\r\n```bash\r\ncurl -X POST http://YOUR_PI_IP:5000/sensehat/light?state=off\r\n```\r\n\r\n+ Find out the IP address of other people in your lab group. You should be able to make requests to their APIs also."
    }
  
  ]
  }

